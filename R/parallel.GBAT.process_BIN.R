#' @description The \code{parallel.GBAT.process_BIN} function allows the user to select a release or version of DCP's Geosupport to more efficiently geocode large data frames (+10,000 records) containing a column of BIN (building identification number).  It aggregates duplicates, geocodes using parallel processing, and then merges the geocoded results back to the original data frame.  The \code{parallel.GBAT.process_BIN} function utilizes Geosupport function BN. 
#'
#' @details Geosupport can be downloaded from \href{https://www1.nyc.gov/site/planning/data-maps/open-data.page#geocoding_application}{DCP BYTES of the BIG APPLE}. Excellent documentation is provide in the \href{https://nycplanning.github.io/Geosupport-UPG/}{Geosupport System User Programming Guide}. The geocoder return fields are described in \href{https://nycplanning.github.io/Geosupport-UPG/appendices/appendix13/}{Appendix 13 of the Geosupport System User Programming Guide}.
#' @title Geocode an extremely large data frame containing a column of BIN with a user selected release or version of DCP's Geosupport.
#' @name parallel.GBAT.process_BIN
#' @aliases parallel.GBAT.process_BIN
#' @import parallel
#' @import data.table
#' @export parallel.GBAT.process_BIN
#' @param in_clus the number of clusters available to the function as integer.  Required.
#' @param in_df a data frame containing NYC addresses.  Required.
#' @param bin_col_name the name of the column containing the input BIN as string.  Required.
#' @param source_cols vector of column names from the input data frame to be returned with geocoder results.  Required.
#' @param geocode_fields vector of field names generated by the geocoder to be returned with geocoder results.  Required.
#' @param return_type option to exclude address which failed to geocode from output as string.  Optional.
#' @param GBAT_name the release or version of DCP's Geosupport geocoding software as string.  Required.
#' @usage parallel.GBAT.process_BIN(in_clus, in_df, bin_col_name, 
#'     source_cols, geocode_fields, return_type = "all", GBAT_name)
#' @return A data frame containing the columns specified in \code{source_cols} plus the geocoder return fields specified in \code{geocode_fields}.
#' @examples #create a large data frame of BIN
#' in_bin <- 1002376
#' BIN <- as.character((in_bin-10000):(in_bin+10000))
#' u_id <- 1:length(BIN)
#' df = data.frame(u_id, BIN)
#'
#' #specify columns from input data frame to retain
#' source_cols <- c('u_id')
#'
#' #specify geocoder return fields
#' geocode_fields <- c("FBN.bbl", "FBN.bin", "FBN.RPAD_lucc",
#'     "FBN.addr_range_1ax1.bin","FBN.addr_range_1ax1.lo_hse_nbr",
#'     "FBN.addr_range_1ax1.hi_hse_nbr","FBN.addr_range_1ax1.st_name",
#'     "FBN.addr_range_1ax2.bin","FBN.addr_range_1ax2.lo_hse_nbr",
#'     "FBN.addr_range_1ax2.hi_hse_nbr","FBN.addr_range_1ax2.st_name",
#'     "FBN.addr_range_1ax3.bin","FBN.addr_range_1ax3.lo_hse_nbr",
#'     "FBN.addr_range_1ax3.hi_hse_nbr","FBN.addr_range_1ax3.st_name")
#'
#' #compare times to geocode a large data frame
#' #with five cores
#' system.time({ df_gc1 <- parallel.GBAT.process_BIN(in_clus=5, in_df=df, 
#'     bin_col_name='BIN', source_cols=source_cols, geocode_fields=geocode_fields, 
#'     return_type="all", GBAT_name="20C")})
#' 
#' #with one core
#' system.time({ df_gc2 <- GBAT.process_BIN(in_df=df, bin_col_name='BIN', 
#'     source_cols=source_cols, geocode_fields=geocode_fields,
#'     return_type="all", GBAT_name="20C")})


parallel.GBAT.process_BIN <- function(in_clus,in_df,bin_col_name,source_cols,geocode_fields,return_type = "all",GBAT_name){

	#short term fix
	data.table::setDTthreads(1) 

	###check where this package is loaded... used for testing purposes when loaded in local libpath###
	my_loc <- gsub("/rGBAT-l","",find.package("rGBAT-l"))

	###algorithm to limit clusters###
	in_clus <- max(min(parallel::detectCores(),20,in_clus,as.integer(nrow(in_df)/1000)),1)
	
	###optimal number of records to prevent bloat###
	chunk <- 5000
	
	iGBAT <- GBAT.check_fields(GBAT_name,c("FBN","all"),geocode_fields)
	
	GBAT.package <- paste0("rGBAT",iGBAT[["GBAT.release"]])
	GBAT.message <- iGBAT[["GBAT.message"]]
	GBAT.status <- iGBAT[["GBAT.status"]]
	GBAT.fields <- iGBAT[["GBAT.fields"]]
	
	new.geocode_fields <- unique(c(GBAT.fields))
	
	###check if any of the fields are generated via a tabular join###
	jf <- joined_fields[GC_fldname %in% new.geocode_fields & !(is.na(GC_join_fld1)) & !(is.na(GC_join_fld2)) & GC_function %in% c("FBN","all"),]
	
	
	if (nrow(jf)>0){
	
		###add fields to join by###
		new.geocode_fields <- unique(c(new.geocode_fields,as.character(jf$GC_join_fld2)))
	
		###remove fields from join tables... these will be added later through a merge###
		new.geocode_fields <- new.geocode_fields[!(new.geocode_fields %in% jf[!(is.na(GC_table))]$GC_fldname)]
	} 
	
	###detect if data.table or data.frame###
	is.DT <- "data.table" %in% class(in_df)
			
	###if data.frame, convert to data.table###
	if(!is.DT) in_df <- as.data.table(in_df)
	
	if(GBAT.status %in% 1:2) {
		
		if(GBAT.status==2) warning(GBAT.message)
		
		###get number of rows in input dt###
		n.r <- nrow(in_df)
		
		###break into cores###
		in_df[,pc := rep(1:in_clus,each=(ceiling(n.r/in_clus)))[1:n.r]]
		
		
		###check what OS is running###
		if(.Platform$OS.type != "windows"){
			parallel::mcaffinity(1:in_clus) #restrict to first 20 cores on server
		}
		
		
		###in order to redefine GEOFILE environment variable within a single R session, parallel environments are used###
		clus <- parallel::makeCluster(in_clus, affinity=1:in_clus) #restrict to first 20 cores on server
		
		###export variables###
		parallel::clusterExport(clus, c("in_clus","in_df",'bin_col_name',"source_cols","GBAT.package","new.geocode_fields","my_loc","chunk",'return_type'), envir=environment())
		
		###load desired version/release of rGBAT package###
		parallel::clusterCall(clus, function() suppressMessages(library(GBAT.package, character.only = TRUE, lib.loc = my_loc)))
		

		out_df <- 
			data.table::rbindlist(parallel::parLapply(clus, 1:in_clus, function(zz) {
			
			###break into chunks###
			in_df.p <- in_df[pc==zz]
		
			nn.r <- nrow(in_df.p)
			
			in_df.p[,pl := rep(1:ceiling(nn.r/chunk),each=chunk)[1:nn.r]]
	
			###lapply chunks###
			return(data.table::rbindlist(lapply(1:max(in_df.p$pl), function(yy)
					get("process_BIN", envir = asNamespace(GBAT.package), inherits = FALSE)(in_df=in_df.p[pl==yy], bin_col_name=bin_col_name, source_cols=source_cols, geocode_fields=new.geocode_fields, return_type=return_type)
			), use.names=TRUE, fill=TRUE))
		}), use.names=TRUE, fill=TRUE)
		
		#terminate cluster
		parallel::stopCluster(clus)
		
		if(.Platform$OS.type != "windows"){
			parallel::mcaffinity(1:parallel::detectCores()) #open all 80 cores back up again
		}
		
		###MERGE HERE!!!###
		if (nrow(jf) > 0){
			###generate vector of tables for later merge###
			jf_tbl <- unique(jf[!(is.na(GC_table)),c('GC_table','GC_join_fld1','GC_join_fld2'),with=FALSE])
			
			for(i in 1:nrow(jf_tbl)){
				out_df <- merge(out_df,get(jf_tbl[i]$GC_table),by.x=as.character(jf_tbl[i]$GC_join_fld2),by.y=as.character(jf_tbl[i]$GC_join_fld1),all.x=TRUE)
			}
			
			###replace NA values###
			for (j in seq_len(ncol(out_df)))
				set(out_df,which(is.na(out_df[[j]])),j,"")
			
			out_df <- out_df[,c(source_cols,unique(c(GBAT.fields))),with=FALSE]
		}
		
		invisible(gc())
		
		if('pc' %in% names(out_df)){
			out_df[,pc := NULL]
		}
		
		if('pl' %in% names(out_df)){
			out_df[,pl := NULL]
		}
		
		if(!is.DT) out_df <- as.data.frame(out_df)
		return(out_df)
		
	} else {
		stop(GBAT.message)
	}
	
	
}
