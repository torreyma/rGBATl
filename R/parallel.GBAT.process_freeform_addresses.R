#' @description The \code{parallel.GBAT.process_freeform_addresses} function allows the user to select a release or version of DCP's Geosupport to more efficiently geocode large data frames (+10,000 records) of freeform NYC addresses where house number and street name are together in one column.  It aggregates, duplicates, geocodes using parallel processing, and then merges the geocoded results back to the original data frame.  The \code{parallel.GBAT.process_freeform_addresses} function utilizes Geosupport functions 1A, 1E, and AP. 
#'
#' @details Geosupport can be downloaded from \href{https://www1.nyc.gov/site/planning/data-maps/open-data.page#geocoding_application}{DCP BYTES of the BIG APPLE}. Excellent documentation is provide in the \href{https://nycplanning.github.io/Geosupport-UPG/}{Geosupport System User Programming Guide}. The geocoder return fields are described in \href{https://nycplanning.github.io/Geosupport-UPG/appendices/appendix13/}{Appendix 13 of the Geosupport System User Programming Guide}.
#' @title Geocode an extremely large data frame of freeform NYC addresses with a user selected release or version of DCP's Geosupport.
#' @name parallel.GBAT.process_freeform_addresses
#' @aliases parallel.GBAT.process_freeform_addresses
#' @import parallel
#' @import data.table
#' @export parallel.GBAT.process_freeform_addresses
#' @param in_clus the number of clusters available to the function as integer.  Required.
#' @param in_df a data frame containing NYC addresses.  Required.
#' @param addr_col_name the name of the input addresses column as string.  Required.
#' @param unit_col_name the name of the unit column as string.  Only available for Geosupport version 16D and later. Optional.
#' @param third_col_name the name of either the borough code or zip code column as string.  Required.
#' @param source_cols vector of column names from the input data frame to be returned with geocoder results.  Required.
#' @param geocode_fields vector of field names generated by the geocoder to be returned with geocoder results.  Required.
#' @param third_col_type either \code{"boro_code"} or \code{"zip_code"} as string.  Required.
#' @param return_type option to exclude address which failed to geocode from output as string.  Optional.
#' @param GBAT_name the release or version of DCP's Geosupport geocoding software as string.  Required.
#' @usage parallel.GBAT.process_freeform_addresses(in_clus, in_df,  
#'     addr_col_name, unit_col_name = NULL, third_col_name, source_cols, 
#'     geocode_fields, third_col_type = "boro_code", 
#'     return_type = "all", GBAT_name)
#' @return A data frame containing the columns specified in \code{source_cols} plus the geocoder return fields specified in \code{geocode_fields}.
#' @examples #create a large data frame of addresses
#' ADDR <- c(paste(1:5000,"BROADWAY"),paste(1:2400,"1 AVE"),
#'     paste(1:3400,"ATLANTIC AVE"), paste(1:3400,"FULTON ST"))
#' BORO_CODE <- ifelse(grepl("ATLANTIC|FULTON",ADDR),3,1)
#' u_id <- 1:length(ADDR)
#' df = data.frame(u_id, ADDR, BORO_CODE)
#'
#' #specify columns from input data frame to retain
#' source_cols <- c('u_id')
#'
#' #specify geocoder return fields
#' geocode_fields <- c('F1E.output.bin','F1E.output.bbl','F1E.longitude',
#'     'F1E.latitude','JN.ZCTA_10','F1E.output.ret_code','F1E.output.msg')
#'
#' #compare times to geocode a large data frame
#' #with five cores
#' system.time({ df_gc1 <- parallel.GBAT.process_freeform_addresses(in_clus=5, in_df=df, 
#'     addr_col_name="ADDR", third_col_name='BORO_CODE', source_cols=source_cols, 
#'     geocode_fields=geocode_fields, third_col_type="boro_code", return_type="all",
#'     GBAT_name="20C")})
#' 
#' #with one core
#' system.time({ df_gc2 <- GBAT.process_freeform_addresses(in_df=df, addr_col_name="ADDR", 
#'     third_col_name='BORO_CODE', source_cols=source_cols, geocode_fields=geocode_fields,
#'     third_col_type="boro_code", return_type="all", GBAT_name="20C")})


parallel.GBAT.process_freeform_addresses <- function(in_clus,in_df,addr_col_name,unit_col_name = NULL,third_col_name,source_cols,geocode_fields,third_col_type,return_type = "all",GBAT_name){

	#short term fix
	data.table::setDTthreads(1) 

	###check where this package is loaded... used for testing purposes when loaded in local libpath###
	my_loc <- gsub("/rGBAT-l","",find.package("rGBAT-l"))

	###algorithm to limit clusters###
	in_clus <- max(min(parallel::detectCores(),20,in_clus,as.integer(nrow(in_df)/1000)),1)
	
	###optimal number of records to prevent bloat###
	chunk <- 5000
	
	iGBAT <- GBAT.check_fields(GBAT_name,c("F1E","all","F1A","FAP"),geocode_fields)
	
	###check if GBAT release has unit input###
	unit.chk <- GBAT.check_fields(GBAT_name,c("F1E"),c("F1E.input.unit"))$GBAT.status
	
	GBAT.package <- paste0("rGBAT",iGBAT[["GBAT.release"]])
	GBAT.message <- iGBAT[["GBAT.message"]]
	GBAT.status <- iGBAT[["GBAT.status"]]
	GBAT.fields <- iGBAT[["GBAT.fields"]]
	
	new.geocode_fields <- unique(c(GBAT.fields))
	
	###check if any of the fields are generated via a tabular join###
	jf <- joined_fields[GC_fldname %in% new.geocode_fields & !(is.na(GC_join_fld1)) & !(is.na(GC_join_fld2)) & GC_function %in% c("F1E","all","F1A","FAP"),]
	
	
	
	if (nrow(jf)>0){
	
		###add fields to join by###
		new.geocode_fields <- unique(c(new.geocode_fields,as.character(jf$GC_join_fld2)))
	
		###remove fields from join tables... these will be added later through a merge###
		new.geocode_fields <- new.geocode_fields[!(new.geocode_fields %in% jf[!(is.na(GC_table))]$GC_fldname)]
	} 
	
	###detect if data.table or data.frame###
	is.DT <- "data.table" %in% class(in_df)
			
	###if data.frame, convert to data.table###
	if(!is.DT) in_df <- as.data.table(in_df)
	
	
	if(GBAT.status %in% 1:2) {
		
		if(GBAT.status==2) warning(GBAT.message)
		
		###get number of rows in input dt###
		n.r <- nrow(in_df)
		
		###break into cores###
		in_df[,pc := rep(1:in_clus,each=(ceiling(n.r/in_clus)))[1:n.r]]
		
		
		###check what OS is running###
		if(.Platform$OS.type != "windows"){
			parallel::mcaffinity(1:in_clus) #restrict to first 20 cores on server
		}
		
		
		###in order to redefine GEOFILE environment variable within a single R session, parallel environments are used###
		clus <- parallel::makeCluster(in_clus, affinity=1:in_clus) #restrict to first 20 cores on server
		
		###export variables###
		parallel::clusterExport(clus, c("in_clus","in_df",'addr_col_name','unit_col_name',"source_cols",'third_col_name',"GBAT.package","new.geocode_fields","my_loc","chunk",'third_col_type','return_type','unit.chk'), envir=environment())
		
		###load desired version/release of rGBAT package###
		parallel::clusterCall(clus, function() suppressMessages(library(GBAT.package, character.only = TRUE, lib.loc = my_loc)))
		

		out_df <- 
			data.table::rbindlist(parallel::parLapply(clus, 1:in_clus, function(zz) {
			
			###break into chunks###
			in_df.p <- in_df[pc==zz]
		
			nn.r <- nrow(in_df.p)
			
			in_df.p[,pl := rep(1:ceiling(nn.r/chunk),each=chunk)[1:nn.r]]
			
			
			if(unit.chk==3){
			
				###lapply chunks###
				return(data.table::rbindlist(lapply(1:max(in_df.p$pl), function(yy)
						get("process_freeform_addresses", envir = asNamespace(GBAT.package), inherits = FALSE)(in_df=in_df.p[pl==yy], addr_col_name=addr_col_name, third_col_name=third_col_name, source_cols=source_cols, geocode_fields=new.geocode_fields, third_col_type=third_col_type, return_type=return_type)
				), use.names=TRUE, fill=TRUE))
			
			} else{
				
				###lapply chunks###
				return(data.table::rbindlist(lapply(1:max(in_df.p$pl), function(yy)
						get("process_freeform_addresses", envir = asNamespace(GBAT.package), inherits = FALSE)(in_df=in_df.p[pl==yy], addr_col_name=addr_col_name, unit_col_name=unit_col_name, third_col_name=third_col_name, source_cols=source_cols, geocode_fields=new.geocode_fields, third_col_type=third_col_type, return_type=return_type)
				), use.names=TRUE, fill=TRUE))
			
			}
			
		}), use.names=TRUE, fill=TRUE)
		
		#terminate cluster
		parallel::stopCluster(clus)
		
		if(.Platform$OS.type != "windows"){
			parallel::mcaffinity(1:parallel::detectCores()) #open all 80 cores back up again
		}
		
		###MERGE HERE!!!###
		if (nrow(jf) > 0){
			###generate vector of tables for later merge###
			jf_tbl <- unique(jf[!(is.na(GC_table)),c('GC_table','GC_join_fld1','GC_join_fld2'),with=FALSE])
			
			for(i in 1:nrow(jf_tbl)){
				out_df <- merge(out_df,get(jf_tbl[i]$GC_table),by.x=as.character(jf_tbl[i]$GC_join_fld2),by.y=as.character(jf_tbl[i]$GC_join_fld1),all.x=TRUE)
			}
			
			###replace NA values###
			for (j in seq_len(ncol(out_df)))
				set(out_df,which(is.na(out_df[[j]])),j,"")
			
			out_df <- out_df[,c(source_cols,unique(c(GBAT.fields))),with=FALSE]
		}
		
		invisible(gc())
		
		if('pc' %in% names(out_df)){
			out_df[,pc := NULL]
		}
		
		if('pl' %in% names(out_df)){
			out_df[,pl := NULL]
		}
		
		if(!is.DT) out_df <- as.data.frame(out_df)
		return(out_df)
		
	} else {
		stop(GBAT.message)
	}
	
	
}
